"""
그리디 알고리즘 
: 현재 상황에서 지금 당장 좋은 것만 고르는 방법
그리디 알고리즘을 이용해 최적의 해를 구할 수 있는 지 검토하는 것이 중요함 
그리디 알고리즘이 최적의 해를 보장할 수 없을 때가 있기 때문 

"""

#----------------------------------------------------------------
print("문제 : 거스름돈")

# 500원, 100원, 50원, 10원짜리 동전으로 거슬러 줄 때, 동전의 개수가 가장 적게 잔돈을 주는 방법/ N은 항상 10의 배수 
# N = 1260 일때 

N = 1260
coins = [500, 100, 50, 10]

count = 0

for coin in coins:
  count += N//coin
  N = N%coin

print(count) # 6


# 가장 큰 단위의 화폐부터 거슬러 주는 것이 최적의 해를 보장하는 이유: 
# 나머지 화폐들의 배수가 큰 단위의 배수이므로 가능 
# 만약 화폐단위가 500, 400, 100 => 그리디로 구한 해가 최적의 해가 못됨 


#----------------------------------------------------------------

print("문제 : 1이 될때 까지") 

# N이 1이 될때까지 다음의 두과정 중 하나를 반복적으로 선택하여 수행
# 1. N에서 1을 뺀다
# 2. N을 K로 나눈다

# N과 K가 주어질 때 N이 1이 될때까지 1번 혹은 2번의 과정을 수행해야 하는 최소 횟수를 구하기 


N, K = 25, 3
result = 0 

while True : 

  target = (N//K)*K
  result += (N-target)
  N = target
  if N < K :
    break 

  result += 1
  N //= K 

# 마지막 남은 수에 대해 1씩 뺴기 
result += (N-1)
print(result)


# 그리디 : 주어진 N에 대해 최대한 많이 나누기를 수행 
# K가 2이상일때 나누기 작없이 1을 빼는 작업보다 작업수를 훨씬 줄일 수 있음 


#----------------------------------------------------------------

print("문제 : 곱하기 혹은 더하기") 

# 각 자리가 0~9까지의 숫자로만 이루어진 문자열 S가 주어질때 
# 왼쪽부터 오른쪽으로 하나씩 모든 숫자 사이에 X 혹은 + 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하기

S = "02984"

result = int(S[0])

for i in range(1, len(S)):
  num = int(S[i])
  if num > 1 and result >1: 
    result *= num
  else: 
    result += num
    
print(result)


# 두수에 대한 연산에서 두수 중 하나라도 1 이하인 경우에는 더하고, 두 수가 모두 2이상인 경우에 곱하면 가장 큰 수를 얻을 수 있음 



#----------------------------------------------------------------

print("문제 : 모헙가 길드")

# 공포도가 X인 모험가는 반드시 X명 이상으로 구성된 모험가 그룹에 참여해야 여행을 떠날 수 있음 
# 여행을 떠날 수 있는 그룹 수의 최댓값을 구하기 

N = 5
data = [2,3,1,2,2]

data.sort()
print(data)

count = 0
result = 0 

for i in data:
  count += 1   # 그룹 인원수 
  if i <= count:  # data값이 그룹 인원수 보다 작거나 같을 때 
    result += 1 # 그룹을 떠나보내기 
    count = 0  # 그룹 인원수 초기화 

print(result)
    
  
