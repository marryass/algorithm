"""
구현 : 시뮬레이션, 완전 탐색 위주로 
: 머리속에 있는 알고리즘을 소스코드로 바꾸는 과정 
풀이는 쉽지만 소스코드로 쉽게 옮기기 어려운 문제 


시뮬레이션 상황에서 행렬 (2차원 리스트)가 많이 사용됨 
행렬 및 방향 벡터의 활용 
"""

# 행렬(2차원 리스트) 표현 
print('행렬(2차원 리스트) 표현')
for i in range(5):
  for j in range(5):
    print('(', i, ',', j, ')', end=' ')
  print()



# 방향 벡터의 사용
print('방향 벡터 사용')
# 동북서남 방향 
dx = [0, -1, 0, 1] # x축 좌표 이동 (x는 세로축의 변화)
dy = [1, 0, -1, 0] # y축 좌표 이동 (y는 가로축의 변화)

x, y = 2, 2 # 현재 위치 

for i in range(4):
  nx = x + dx[i]
  ny = y + dy[i]
  print(nx, ny)



#--------------------------------------------------------------------
# 문제 : 상하좌우
print('문제 : 상하좌우')

'''
여행가 A는 N × N 크기의 정사각형 공간 위에 서 있습니다. 이 공간은 1 × 1 크기의 정사각형으로 나누어져 있습니다. 가장 왼쪽 위 좌표는 (1, 1)이며, 가장 오른쪽 아래 좌표는 (N, N)에 해당합니다. 
여행가 A는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1, 1)입니다. 우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여 있습니다.
계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L, R, U, D 중 하나의 문자가 반복적으로 적혀 있습니다. 각 문자의 의미는 다음과 같습니다.
• L: 왼쪽으로 한 칸 이동
• R: 오른쪽으로 한 칸 이동
• U: 위로 한 칸 이동
• D: 아래로 한 칸 이동

입력 조건
• 첫째 줄에 공간의 크기를 나타내는 N이 주어집니다. (1 <= N <= 100)
• 둘째 줄에 여행가 A가 이동할 계획서 내용이 주어집니다. (1 <= 이동 횟수 〈= 100)

출력 조건 
• 첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표 (X, Y)를 공백을 기준으로 구분하여 출력합니다.

'''

N = 5
plans = ['R', 'R', 'R', 'U', 'D', 'D']

x, y = 1, 1  # 현재 좌표 위치 
dx = [0, 0, -1, 1] # L, R, U, D 이동 방향 
dy = [-1, 1, 0, 0]
move_types = ['L', 'R', 'U', 'D']


for plan in plans:
  for i in range(len(move_types)):
    if move_types[i] == plan:
      nx = x + dx[i]
      ny = y + dy[i]

  if nx >= 1 and ny >= 1 and nx <= N and ny <= N:  # 좌표 범위 안에 있으면
    x = nx
    y = ny
      
print(x, y)



#--------------------------------------------------------------------
# 문제 : 시각 
print('문제 : 시각')
# 정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우이 수를 구하는 프로그램을 작성

N = 5
count = 0 

for i in range(N+1):
  for j in range(60):
    for k in range(60):
      time = str(i)+str(j)+str(k)
      if '3' in time:
        count += 1

print(count)



#--------------------------------------------------------------------
# 문제 : 왕실의 나이트  
print('문제 : 왕실의 나이트')

'''
8X8 좌표 평면 : 
행 위치 표현은 1~8까지, 열 위치 표현은 a~h 까지 

나이트의 이동 조건 : 
1. 수평으로 두칸 이동 후 수직으로 한칸 이동 
2. 수직으로 두칸 이동 후 수평으로 한칸 이동 

입력 조건 
첫째 줄에 8X8 좌표 평면상에서 현재 나이트가 위치한 곳의 좌표를 나타내는 두 문자로 구성된 문자열이 입력된다. (예: a1 )

출력 조건 
첫째 줄에 나이트가 이동할 수 있는 경우의 수를 출력한다. 

'''

position = 'c2'
x = ord(position[0]) - ord('a') + 1  # a부터 h까지 1~8로 바꿔줌 
y = int(position[1])
directions = [(2, 1), (2, -1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (1, -2), (-1, -2)]

count = 0

for i in directions: 
  nx = x + i[0]
  ny = y + i[1]
  # print(nx, ny)

  if 1 <= nx <= 8 and 1 <= ny <= 8:
    count += 1

print(count)




#--------------------------------------------------------------------
# 문제 : 문자열 재정렬
print('문제 : 문자열 재정렬')

'''
알파벳 대문자와 숫자(0 ~ 9)로만 구성된 문자열이 입력으로 주어집니다. 이때 모든 알파벳을 오름차순으로 정렬하여 이어서 출력한 뒤에, 그 뒤에 모든 숫자를 더한 값을 이어서 출력합니다.
예를 들어 K1KA5CB7이라는 값이 들어오면 ABCKK13을 출력합니다.
'''

data = 'K1KA5CB7'

result = []  # 문자들을 담을 공간 
sum = 0  # 숫자들 합 담을 공간 


for i in data:
  if i.isalpha():
    result.append(i)
  else:
    sum += int(i)


result.sort()  # 문자들 오름차순 정렬 

if sum != 0:  # 숫자합이 0이 아닌 경우 
  result.append(str(sum)) 
  
print(''.join(result))

  

  
